# Your custom artisan/testbench function
art() {
    # Check if vendor/bin/testbench exists and is executable
    if [ -x "vendor/bin/testbench" ]; then
        echo "Running vendor/bin/testbench with supplied parameters..."
        ./vendor/bin/testbench "$@"
    # Check if artisan exists and is executable
    elif [ -x "artisan" ]; then
        echo "Running artisan with supplied parameters..."
        php artisan "$@"
    else
        echo "Error: Neither vendor/bin/testbench nor artisan could be found or they are not executable."
        return 1 # Exit the function with an error status
    fi
}

# Your custom commit function
commit() {
  local args=()
  local msg=""
  local author=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --amend|-n|-S|--signoff)
        args+=("$1")
        ;;
      --author)
        shift
        author="$1"
        ;;
      -m|--message)
        shift
        msg="$1"
        ;;
      *)
        # Build message from remaining words
        if [[ -z "$msg" ]]; then
          msg="$1"
        else
          msg="$msg $1"
        fi
        ;;
    esac
    shift
  done

  if [[ -z "$msg" ]]; then
    echo "No commit message provided."
    return 1
  fi

  if [[ -n "$author" ]]; then
    args+=("--author=$author")
  fi

  git commit "${args[@]}" -m "$msg"
}

# Rename branch
renamebranch() {
  git branch -m "$1" "$2"
}

# Stage all and commit quickly
quickcommit() {
  git add . && commit "$@"
}

# Run tests
function p() {
   if [ -f vendor/bin/pest ]; then
      vendor/bin/pest "$@"
   else
      vendor/bin/phpunit "$@"
   fi
}

function pf() {
   if [ -f vendor/bin/pest ]; then
      vendor/bin/pest --filter "$@"
   else
      vendor/bin/phpunit --filter "$@"
   fi
}

# Docker
function ssh-docker() {
   docker exec -it "$@" bash
}

# Create a new directory and enter it
function mkd() {
   mkdir -p "$@" && cd "$@"
}

# Start an HTTP server from a directory, optionally specifying the port
function server() {
	local port="${1:-9000}"
	sleep 2 && open "http://localhost:${port}/" &
	# Set the default Content-Type to `text/plain` instead of `application/octet-stream`
	# And serve everything as UTF-8 (although not technically correct, this doesnâ€™t break anything for binary files)
	python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port"
}

# Start a PHP server from a directory, optionally specifying the port
# (Requires PHP 5.4.0+.)
function phpserver() {
	local port="${1:-4000}"
	local ip=$(ipconfig getifaddr en0)
	sleep 2 && open "http://${ip}:${port}/" &
	php -S "${ip}:${port}"
}

# All the dig info
function digga() {
	dig +nocmd "$1" any +multiline +noall +answer
}

function tinker()
{
  if [ -z "$1" ]
    then
       php artisan tinker
    else
       php artisan tinker --execute="dd($1);"
  fi
}

#shortcut voor zhs quick-look command
function ql() {
   quick-look "$1"
}

archive () {
   zip -r "$1".zip -i "$1" ;
}

function removehost() {
   ssh-keygen -R "$1"
}

function weather() {
   local city="${1:-Antwerp}"
   curl http://wttr.in/${city// /+}\?F
}

# Scrape a single webpage with all assets
function scrapeUrl() {
    wget --adjust-extension --convert-links --page-requisites --span-hosts --no-host-directories "$1"
}

xdebug() {
   iniFileLocation="/usr/local/etc/php/7.4/php.ini";
   
   currentLine=`cat $iniFileLocation | grep xdebug.so`

   if [[ $currentLine =~ ^#zend_extension ]];
   then
      sed -i -e 's/^#zend_extension/zend_extension/g' $iniFileLocation
      echo "xdebug is now active";
   else
      sed -i -e 's/^zend_extension/#zend_extension/g' $iniFileLocation
      echo "xdebug is now inactive";
   fi
}

function db {
    if [ "$1" = "refresh" ]; then
        mysql -uroot -e "drop database $2; create database $2"
    elif [ "$1" = "create" ]; then
        mysql -uroot -e "create database $2"
    elif [ "$1" = "drop" ]; then
        mysql -uroot -e "drop database $2"
    elif [ "$1" = "list" ]; then
        mysql -uroot -e "show databases" | perl -p -e's/\|| *//g'
    fi
}

function opendb () {
   [ ! -f .env ] && { echo "No .env file found."; exit 1; }

   DB_CONNECTION=$(grep DB_CONNECTION .env | grep -v -e '^\s*#' | cut -d '=' -f 2-)
   DB_HOST=$(grep DB_HOST .env | grep -v -e '^\s*#' | cut -d '=' -f 2-)
   DB_PORT=$(grep DB_PORT .env | grep -v -e '^\s*#' | cut -d '=' -f 2-)
   DB_DATABASE=$(grep DB_DATABASE .env | grep -v -e '^\s*#' | cut -d '=' -f 2-)
   DB_USERNAME=$(grep DB_USERNAME .env | grep -v -e '^\s*#' | cut -d '=' -f 2-)
   DB_PASSWORD=$(grep DB_PASSWORD .env | grep -v -e '^\s*#' | cut -d '=' -f 2-)

   DB_URL="${DB_CONNECTION}://${DB_USERNAME}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT}/${DB_DATABASE}"

   echo "Opening ${DB_URL}"
   open $DB_URL
}

function scheduler () {
    while :; do
        php artisan schedule:run
	echo "Sleeping 60 seconds..."
        sleep 60
    done
}

function silent() {
   "$@" >& /dev/null
}

function browse() {
  url="https://$(basename "$(pwd)").test"
  open "$url"
}

function git-prune-local() {
  echo "Finding local branches without remote counterparts..."
  
  # Get all local branches except main/master
  local_branches=$(git branch --format='%(refname:short)' | grep -v "^main$\|^master$")
  
  # Get all remote branches without fetching
  remote_branches=$(git ls-remote --heads origin | sed 's/.*refs\/heads\///')
  
  branches_to_delete=()
  
  # Check each local branch if it exists on remote
  for branch in ${(f)local_branches}; do
    found=0
    for remote_branch in ${(f)remote_branches}; do
      if [[ "$branch" == "$remote_branch" ]]; then
        found=1
        break
      fi
    done
    if [[ $found -eq 0 ]]; then
      branches_to_delete+=("$branch")
    fi
  done
  
  if [[ ${#branches_to_delete[@]} -eq 0 ]]; then
    echo "No branches to remove."
    return
  fi
  
  echo "Branches to be removed:"
  printf '%s\n' "${branches_to_delete[@]}"
  
  # Ask for confirmation
  read "REPLY?Are you sure you want to delete these branches? (y/N): "
  if [[ $REPLY =~ ^[Yy]$ ]]; then
    for branch in "${branches_to_delete[@]}"; do
      git branch -D "$branch"
    done
    echo "Branches removed successfully."
  else
    echo "Operation cancelled."
  fi
}

function symlinks() {
  echo 'Re-creating dotfiles symlinks...'
  source ~/.dotfiles/symlinks
}

# Tmux session management (beta)
function sesh() {
  local session_name=$(basename "$PWD")
  
  # Parse session name: convert .dotfiles to _dotfiles
  session_name=${session_name//./_}
  
  if ! command -v tmux >/dev/null 2>&1; then
    echo "tmux is not installed"
    return 1
  fi
  
  if tmux has-session -t "$session_name" 2>/dev/null; then
    echo "Attaching to existing session: $session_name"
    tmux attach-session -t "$session_name"
  else
    echo "Creating new session: $session_name"
    tmux new-session -s "$session_name"
  fi
}

# Close current tmux session (beta)
function bye() {
  if [ -z "$TMUX" ]; then
    echo "Not in a tmux session"
    return 1
  fi
  
  local current_session=$(tmux display-message -p '#S')
  # Parse session name: convert _dotfiles back to .dotfiles for display
  local display_session=${current_session//_/.}
  echo "Closing session: $display_session"
  tmux kill-session
}

# Rector wrapper function
rec() {
  if [ ! -f "./rector.php" ]; then
    echo "Copying rector.php from dotfiles..."
    cp ~/.dotfiles/rector.php ./rector.php
    
    # Find PHP directories and files
    local php_dirs=()
    
    # Check for PHP files in root directory and add their full paths
    while IFS= read -r -d '' file; do
      if [[ "$file" == "./vendor/"* ]] || [[ "$file" == "./node_modules/"* ]]; then
        continue
      fi
      php_dirs+=("__DIR__ . '/${file#./}'")
    done < <(find . -maxdepth 1 -name "*.php" -type f -print0)
    
    # Check common directories that might contain PHP files
    local common_dirs=("src" "app" "lib" "tests" "test")
    for dir in "${common_dirs[@]}"; do
      if [ -d "$dir" ] && find "$dir" -name "*.php" -type f | grep -q .; then
        php_dirs+=("__DIR__ . '/$dir'")
      fi
    done
    
    # Replace placeholder with detected paths
    if [ ${#php_dirs[@]} -gt 0 ]; then
      # Create temporary file with the paths
      local temp_file=$(mktemp)
      for dir in "${php_dirs[@]}"; do
        echo "        $dir," >> "$temp_file"
      done
      
      # Remove trailing comma from last line
      sed -i '' '$ s/,$//' "$temp_file"
      
      # Replace placeholder using awk
      awk '
        /\/\/ Add your paths here/ {
          while ((getline line < "'$temp_file'") > 0) {
            print line
          }
          close("'$temp_file'")
          next
        }
        { print }
      ' rector.php > rector.php.tmp && mv rector.php.tmp rector.php
      
      rm -f "$temp_file"
    fi
    
    echo "Created rector.php with detected PHP paths"
  fi
  
  rector --config "./rector.php" "$@"
}

# Clean null-ls temporary files
function clean-null-ls() {
  local count=0
  
  # Find and delete .null-ls_* files recursively
  while IFS= read -r -d '' file; do
    if rm "$file" 2>/dev/null; then
      echo "Deleted: $file"
      ((count++))
    fi
  done < <(find . -name '.null-ls_*' -type f -print0 2>/dev/null)
  
  if [ $count -eq 0 ]; then
    echo "No .null-ls_* files found"
  else
    echo "Cleaned $count null-ls temporary files"
  fi
}
